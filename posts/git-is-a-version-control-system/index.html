<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-gb lang=en-gb><head><script src=https://blog.gpkb.org/js/early.min.8bbbb9e374f9a31ff012ccd8e17b750da15211875e9e896d6ea765d7e3c2179a.js integrity="sha256-i7u543T5ox/wEszY4Xt1DaFSEYdenoltbqdl1+PCF5o="></script><script defer language=javascript type=text/javascript src=/js/bundle.min.4743996bb4dba309b08ff420c6719508b909626ff9f7294e9bf1ece9a5847c34.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=color-scheme content="light dark"><title itemprop=name>gpk blog - Git is a Version Control System</title>
<meta property="og:title" content="gpk blog - Git is a Version Control System"><meta name=twitter:title content="gpk blog - Git is a Version Control System"><meta itemprop=name content="gpk blog - Git is a Version Control System"><meta name=application-name content="gpk blog - Git is a Version Control System"><meta property="og:site_name" content><meta name=description content><meta itemprop=description content><meta property="og:description" content><meta name=twitter:description content><base href=https://blog.gpkb.org/posts/git-is-a-version-control-system/><link rel=canonical href=https://blog.gpkb.org/posts/git-is-a-version-control-system/ itemprop=url><meta name=url content="https://blog.gpkb.org/posts/git-is-a-version-control-system/"><meta name=twitter:url content="https://blog.gpkb.org/posts/git-is-a-version-control-system/"><meta property="og:url" content="https://blog.gpkb.org/posts/git-is-a-version-control-system/"><meta property="og:updated_time" content=14003-14-10T321:00:24Z><link rel=sitemap type=application/xml title=Sitemap href=https://blog.gpkb.org/sitemap.xml><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta name=twitter:site content><meta name=twitter:creator content><meta property="fb:admins" content><meta name=apple-mobile-web-app-title content><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=generator content="Hugo 0.131.0"><script></script><link type=text/css rel=stylesheet href=/css/bundle.min.07f3dd0396574541faa1c2fefc408713f1067b7f637fcc592e579d2fa30c91bd.css><style>:root{--sidebar-bg-color:#202420;--sidebar-img-border-color:#515751;--sidebar-p-color:#909090;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--toc-color:#7a7a7a;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#222;--link-color:#268bd2;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#222;--code-background-color:#cfcbcf;--code-block-color:#000;--code-block-background-color:#dfdbdf;--moon-sun-color:#FFF;--moon-sun-background-color:#515751}@media screen{[data-theme=dark]{--text-color:#eee;--toc-color:#9d9d9d;--bkg-color:#121212;--post-title-color:#DBE2E9;--list-color:#eee;--link-color:#268bd2;--date-color:#9a9a9a;--table-border-color:#515151;--table-stripe-color:#202020;--code-color:#eee;--code-background-color:#303430;--code-block-color:#fff;--code-block-background-color:#202420}}body{background-color:var(--bkg-color)}</style><meta name=google-site-verification content="0kCOfXcz_aAJKh_eZglpQdpUUfE2IqecYZesW3oUOJo"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400;1,700&family=Vollkorn:ital,wght@0,800;1,800&display=swap" rel=stylesheet><link rel=stylesheet href=https://blog.gpkb.org/css/maplibre-gl.576b085fdd9487a65a19215328c1e086c07ce5bf6da09b666b3806d3d008dae9.css><script defer src=https://blog.gpkb.org/js/global.min.e29b2e1124fb310cfd296f28da7a875d5b6a01725c8219a2a7e7a6a428cba88a.js integrity="sha256-4psuEST7MQz9KW8o2nqHXVtqAXJcghmip+empCjLqIo="></script></head><body><div class=wrapper><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://blog.gpkb.org/ class=brand-image><img src=/android-chrome-512x512.png alt="brand image"></a><h1 class=brand><a href=https://blog.gpkb.org/><h1>gpk blog</h1></a></h1><p class=lead>My ramblings about emacs, the internet and everything</p><div class=light-dark align=right><button class=btn-light-dark title="Toggle light/dark mode"><svg display="none" class="moon" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg display="none" class="sun" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button></div></div><nav><ul class=sidebar-nav><li class=heading><a href=/about/>About</a></li><li class=heading><a href=/categories/>Categories</a></li><li class=heading><a href=/tags/>Tags</a></li></ul></nav><div class=socials><a target=_blank class=social title=GitHub href=https://github.com/georgek><svg width="1.2em" height="1.2em" viewBox="-2 -2 24 24"><path fill="currentcolor" d="M18.88 1.099C18.147.366 17.265.0 16.233.0H3.746C2.714.0 1.832.366 1.099 1.099.366 1.832.0 2.714.0 3.746v12.487c0 1.032.366 1.914 1.099 2.647.733.733 1.615 1.099 2.647 1.099H6.66c.19.0.333-.007.429-.02a.504.504.0 00.286-.169c.095-.1.143-.245.143-.435l-.007-.885c-.004-.564-.006-1.01-.006-1.34l-.3.052c-.19.035-.43.05-.721.046a5.555 5.555.0 01-.904-.091 2.026 2.026.0 01-.872-.39 1.651 1.651.0 01-.572-.8l-.13-.3a3.25 3.25.0 00-.41-.663c-.186-.243-.375-.407-.566-.494l-.09-.065a.956.956.0 01-.17-.156.723.723.0 01-.117-.182c-.026-.061-.004-.111.065-.15.07-.04.195-.059.378-.059l.26.04c.173.034.388.138.643.311a2.1 2.1.0 01.631.677c.2.355.44.626.722.813.282.186.566.28.852.28.286.0.533-.022.742-.065a2.59 2.59.0 00.585-.196c.078-.58.29-1.028.637-1.34a8.907 8.907.0 01-1.333-.234 5.314 5.314.0 01-1.223-.507 3.5 3.5.0 01-1.047-.872c-.277-.347-.505-.802-.683-1.365-.177-.564-.266-1.215-.266-1.952.0-1.049.342-1.942 1.027-2.68-.32-.788-.29-1.673.091-2.652.252-.079.625-.02 1.119.175.494.195.856.362 1.086.5.23.14.414.257.553.352a9.233 9.233.0 012.497-.338c.859.0 1.691.113 2.498.338l.494-.312a6.997 6.997.0 011.197-.572c.46-.174.81-.221 1.054-.143.39.98.424 1.864.103 2.653.685.737 1.028 1.63 1.028 2.68.0.737-.089 1.39-.267 1.957-.177.568-.407 1.023-.689 1.366a3.65 3.65.0 01-1.053.865c-.42.234-.828.403-1.223.507a8.9 8.9.0 01-1.333.235c.45.39.676 1.005.676 1.846v3.11c0 .147.021.266.065.357a.36.36.0 00.208.189c.096.034.18.056.254.064.074.01.18.013.318.013h2.914c1.032.0 1.914-.366 2.647-1.099.732-.732 1.099-1.615 1.099-2.647V3.746c0-1.032-.367-1.914-1.1-2.647z"/></svg>
</a><a target=_blank class=social title=Gitlab href=https://gitlab.com/gkettleborough><svg width="1.2em" height="1.2em" viewBox="-2 -2.5 24 24"><path fill="currentcolor" d="M10.006 18.443 6.326 7.118h7.36l-3.68 11.325zm0 0L1.168 7.118h5.158l3.68 11.325zM1.168 7.118l8.838 11.325-9.68-7.032a.762.762.0 01-.276-.852l1.118-3.441zm0 0L3.385.296a.38.38.0 01.724.0l2.217 6.822H1.168zm8.838 11.325 3.68-11.325h5.157l-8.837 11.325zm8.837-11.325 1.119 3.441a.762.762.0 01-.277.852l-9.68 7.032 8.838-11.325zm0 0h-5.157L15.902.296a.38.38.0 01.725.0l2.216 6.822z"/></svg>
</a><a target=_blank class=social title="RSS Feed" href=/posts/index.xml><svg width="1em" height="1.2em" viewBox="0 0 1280 1280"><g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)" fill="currentcolor"><path d="M2295 11929c-284-12-642-45-707-65-17-5-18-63-18-1039 0-569 4-1036 8-1039 5-3 74 6 153 19 510 86 1168 95 1789 25 1348-153 2602-677 3670-1531 385-308 820-744 1126-1129 842-1060 1362-2313 1514-3650 70-621 61-1279-25-1789-13-79-22-148-19-153 3-4 471-8 1039-8h1035l5 23c51 225 85 942 67 1419-23 605-77 1044-198 1617-294 14e2-927 2734-1823 3846-1043 1295-2364 2259-3909 2854-1158 447-2451 656-3707 6e2z"/><path d="M2255 7845c-269-25-620-81-667-106-17-9-18-55-18-899 0-706 3-890 13-890 6 0 66 18 132 41 130 44 288 79 467 105 154 21 577 30 749 15 1207-107 2267-823 2814-1902 166-327 268-637 330-1001 38-227 48-384 42-662-8-348-44-590-126-831-23-66-41-126-41-132 0-10 184-13 890-13 844 0 890 1 899 18 27 50 88 452 110 725 14 162 14 624 1 782-59 703-233 1323-545 1945-481 956-1313 1788-2270 2268-620 310-1239 483-1940 542-165 14-669 10-840-5z"/><path d="M2519 3815c-391-66-725-336-868-703-79-201-96-462-45-677 83-344 338-641 666-774 116-47 205-69 330-80 412-39 811 153 1040 5e2 193 292 240 648 128 981-135 403-492 699-914 757-1e2 14-241 12-337-4z"/></g></svg>
</a><a target=_blank class=social title=Email href=mailto://kettlegatgmail.com><svg width="1em" height="1.2em" viewBox="0 0 485.211 485.211"><path fill="currentcolor" d="M301.393 241.631 464.866 424.56H20.332l163.474-182.928 58.801 51.443 58.786-51.444zM462.174 60.651H23.027l219.579 192.142L462.174 60.651zM324.225 221.67l160.986 180.151V80.792L324.225 221.67zM0 80.792v321.029L160.972 221.64.0 80.792z"/></svg></a></div><p class=footnote>Powered by <a target=_blank href=https://gohugo.io>Hugo</a> | Themed with <a target=_blank href=https://github.com/georgek/poison>Poison</a></p><p class=footnote>© George Kettleborough
<a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer">CC BY-SA 4.0</a></p></div></aside><main class="content container"><div class=post><article><header><div class=info><h1 class=post-title><a href=https://blog.gpkb.org/posts/git-is-a-version-control-system/>Git is a Version Control System</a></h1><span class=post-meta><span class=post-author><span class=nowrap>George Kettleborough</span>
·
<span class=nowrap><time datetime=2024-02-24T17:23:00Z class=post-date>February 24, 2024
</time></span>·
<span class=nowrap>(Updated
<time datetime=2024-03-14T22:21:00Z class=post-date>March 14, 2024
</time>)</span></span><ul class=tags><li class=tag-git><a href=https://blog.gpkb.org/tags/git>git</a></li><li class=tag-vcs><a href=https://blog.gpkb.org/tags/vcs>vcs</a></li></ul></span></div></header><p>The title of this post isn&rsquo;t supposed to be provocative. After all, it&rsquo;s simply the
textbook definition of what git is. So why bother stating it? Well, I&rsquo;ve worked with a
fair few junior developers now and I&rsquo;m starting to see a pattern. Many of these
developers have never programmed <em>without</em> git and they see git simply as &ldquo;the way to
get new code into a repository&rdquo;. A glorified copy, essentially&mdash;but an annoying one
that is prone to going wrong.</p><p>But git is so much more than a glorified copy. In this post I want to go back to basics
and show what a version control system is and what it can do for you. I hope this will
provide a different view of git that might help you in your git journey.</p><section class=outline-1><h2 id=dumb-version-control>Dumb version control</h2><p>Back in the day, before everything was on the cloud, it was frighteningly common to see
the following turn up in an email attachment:</p><p><code>important-document-v6-2024-02-16-(gpk).doc</code></p><p>People who knew better would scoff at this, but what you&rsquo;re seeing here is version
control. It&rsquo;s just very manual, dumb version control. It was scoffed it because it&rsquo;s the
kind of thing that is prone to going wrong, but if implemented very carefully, it could
go right. Here&rsquo;s how it might work:</p><ol><li>Type up the first version of a document, say <code>important-document.doc</code>,</li><li>Make a copy of that, called <code>important-document-v1.doc</code>,</li><li>Continue making further additions/edits to <code>important-document.doc</code>,</li><li>Make another copy of that, called <code>important-document-v2.doc</code>.</li></ol><p>The important thing here is discipline. For this to go well, the <code>v1</code>, <code>v2</code> documents
must never be edited again or you&rsquo;ll undermine the whole system. To make it easier to do
the right thing the dumb version control user might opt to keep the untouchable copies
in a hidden directory, like <code>.vcs</code>, which might look like:</p><pre tabindex=0><code class=language-:linenos data-lang=:linenos>.
├── important-document.doc
└── .vcs
    ├── important-document-v1.doc
    └── important-document-v2.doc
</code></pre><p>What about those other parts in the first example, like the <code>(gpk)</code>? These are to enable
collaboration. The way this worked is you would send <code>v6</code> to me, then continue working
and produce a <code>v7</code>. Later, I would send you back some corrections. You now have two
branches that need to be reconciled. And that&rsquo;s exactly what people would do, they would
go through the corrected <code>v6-(gpk)</code> and apply all the changes to <code>v7</code>. People just kept
this stuff in their head and, for the most part, it kind of worked.</p></section><section class=outline-1><h2 id=git-is-dumb-version-control>Git is dumb version control</h2><p>The big secret is git is, in essence, nothing more than an implementation of the above
system, with one small difference.</p><p>The first thing to understand about git is <strong>a commit is a copy of your entire working
directory</strong>. This also means a commit and a version are the same thing. Just like the
dumb system, making a commit is nothing more than copying the current <strong>working
directory</strong> into a separate storage place. With git, the storage place is actually a
<code>.git</code> directory.</p><p>The second, and arguably most important, thing to understand is <strong>commits are
immutable</strong>. Remember in the dumb system we said we must not ever touch the <code>v1</code>, <code>v2</code>
etc. copies? Git enforces this. There is no command in git that can modify, overwrite or
delete any commit that has been made.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>The small difference between the dumb system and git is what version numbers look
like. In the dumb system we used a linear sequence of numbers. But this falls apart as
soon as we have a second person working on a project. Essentially, my <code>v2</code> and your <code>v2</code>
are different versions and if we ever hope to merge these together the system needs to
be able to store them and refer to them at the same time.</p><p>There are many solutions to this problem, but git&rsquo;s solution is simple: it uses the hash
of the entire commit as the version number. These are virtually guaranteed to be
universally unique. But, since hashes are not sequential, it also stores a link to the
previous version with every version to establish the lineage.</p></section><section class=outline-1><h2 id=doing-dumb-things-with-git>Doing dumb things with git</h2><p>So how do we actually use git? Let&rsquo;s compare and contrast the dumb version control
system with git. Note the dumb VCS commands are supposed to be illustrative and almost
certainly don&rsquo;t work in all cases (like with hidden files/dirs). Also note, when there
are multiple commands they are to be taken together as atomic operations; I&rsquo;m not saying
the individual commands are analogous to each other.</p><section class=outline-2><h3 id=making-a-commit>Making a commit</h3><p>To make a new commit in the dumb system we copy the working copy into the <code>.vcs</code>
directory:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>mkdir .vcs/v6
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">2</span><span>cp -r * .vcs/v6
</span></span></code></pre></div><p>Note we have to somehow know that <code>v6</code> is the next version number.</p><p>In git we do:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git add -A
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">2</span><span>git commit -m <span style=color:#2aa198>&#34;New version&#34;</span>
</span></span></code></pre></div><p>We didn&rsquo;t have to know the previous version number, nor the new version number. Git
instead tells us the hash of the new version after it&rsquo;s done.</p></section><section class=outline-2><h3 id=checkout-an-old-version>Checkout an old version</h3><p>In the dumb system we must first wipe our working copy then copy the version we want:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>rm -r *
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">2</span><span>cp -r .vcs/v1/* .
</span></span></code></pre></div><p>Note the symmetry between commit and checkout.</p><p>With git we need to specify a version somehow. We could use a hash, or a relative lookup
like <code>HEAD^</code>, which means the previous commit to the one currently checked out (recall
git stores a link to the previous commit with every commit):</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git checkout HEAD^
</span></span></code></pre></div><p>Git warns us about being in a detached head state because anything you do in this state
is kind of difficult to keep track of unless you&rsquo;re good at remembering commit hashes.</p><p>It turns out checkout is actually a pretty rare thing to do in git, but it&rsquo;s included
for completeness.</p></section><section class=outline-2><h3 id=using-meaningful-version-labels>Using meaningful version labels</h3><p>In the dumb system the version labels are up to us. The <code>v1</code> labels are already
meaningful, but we could use even more meaningful labels if we wish:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>mkdir .vcs/v6-test2
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">2</span><span>cp -r * .vcs/v6-test2
</span></span></code></pre></div><p>In git, we can&rsquo;t change the hashes, but we can add as many <em>additional</em> labels to a
commit as we like. There are two types of labels in git: branches and tags.</p><p>To create a new branch <code>new-branch</code> that labels a commit <code>124b7c6</code>:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git branch new-branch 124b7c6
</span></span></code></pre></div><p>To create a tag <code>new-tag</code> that labels the same commit:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git tag -am <span style=color:#2aa198>&#34;New tag&#34;</span> new-tag 124b7c6
</span></span></code></pre></div><p>Note that in both cases we have only added <em>labels</em> to existing commits. Nothing else
has changed.</p><p>We can use our meaningful names instead of hashes, for example to create another tag
for the very same commit:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git tag -am <span style=color:#2aa198>&#34;Another tag&#34;</span> another-tag new-branch
</span></span></code></pre></div><p>The difference between branches and tags are branches are mutable while tags are
immutable. If you make a commit git <strong>updates</strong> your current branch (if there is one) to
point to the new commit. Tags, on the other hand, will forever point to the same commit.</p></section><section class=outline-2><h3 id=what-is-the-current-version-branch>What is the current version/branch?</h3><p>In the dumb system you just store the current version in your head. Since we were using
sequential numbers you could know by inspecting the <code>.vcs</code> directory and seeing the
largest number is <code>v6</code>. This is how you would know the next version is to be <code>v7</code>.</p><p>Git stores the current version/branch in <em>its</em> head. Quite literally, in a file called
<code>HEAD</code>. You can check this in any git repository by running <code>cat .git/HEAD</code>. You would
probably see something like <code>ref: refs/heads/master</code>.</p><p>This is how git &ldquo;knows&rdquo; what the previous version is when you make a commit. It&rsquo;s also
how it knows which branch to update when you make a commit.</p><p>You can use <code>HEAD</code> as a label in its own right as we saw above when we checked out
<code>HEAD^</code> (the <code>^</code> is a relative lookup and means the parent of <code>HEAD</code> in this case).</p><p>A detached head state happens when you checkout a commit directly using its hash. If you
were to look at <code>.git/HEAD</code> in this state you would see an entire commit hash instead of
a ref. If you make commits in this state there is no branch to update so these commits
can only be found using their hash. Git warns you before and after leaving a detached
head state. If in doubt, create a branch like it tells you to do!</p></section><section class=outline-2><h3 id=syncing-with-a-remote>Syncing with a remote</h3><p>With the dumb system, syncing to a remote can be done using any sync tool, like rsync:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>rsync .vcs my-server:my-project
</span></span></code></pre></div><p>This copies just the <code>.vcs</code> directory so everything we have so far committed.</p><p>Git is much more clever in this regard as it tries to minimise the amount of data it
sends and manages your remotes itself, but you can do something similar like this:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git remote add my-remote my-server
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">2</span><span>git push my-remote --follow-tags <span style=color:#2aa198>&#39;*:*&#39;</span>
</span></span></code></pre></div><p>This pushes all commits as well as all branches and all tags.</p><p>Note that in neither case is your working directory transferred. Only things you have
already committed.</p></section><section class=outline-2><h3 id=differences-between-versions>Differences between versions</h3><p>In the dumb system, we can use the standard <code>diff</code> tool to see the differences between
two versions:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>diff -ur .vcs/v2 .vcs/v3
</span></span></code></pre></div><p>Git has a much more powerful and specialised diff tool built in and there are many
different ways to invoke it, but to compare two versions, say <code>a1bf365</code> and <code>main</code> it
looks almost the same:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git diff a1bf365 main
</span></span></code></pre></div></section></section><section class=outline-1><h2 id=beyond-dumb-version-control>Beyond dumb version control</h2><p>So why use git at all then? So far we&rsquo;ve seen it can all be done using simple tools and
some discipline. Let&rsquo;s look at what git can do beyond the dumb system.</p><section class=outline-2><h3 id=composing-commits>Composing commits</h3><p>You might have noticed git required two commands to make a commit. One of them is called
<code>commit</code>, which makes sense, but what is <code>add</code>? Well, unlike the dumb version control
system, git lets us choose what to add to the next commit. Imagine you made two
unrelated changes, one in <code>file1</code> and another in <code>file2</code>. To make your next version to
contain only the change in <code>file1</code>:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git add file1
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">2</span><span>git commit -m <span style=color:#2aa198>&#34;Changes to file1&#34;</span>
</span></span></code></pre></div><p>You can go even further and break down files line by line using <code>git add -p</code>, but I find
this is something much easier to achieve with a graphical git client.</p><p>This makes it much easier to produce <em>atomic</em> commits rather than one big commit with a
bunch of unrelated changes at the end of the day.</p></section><section class=outline-2><h3 id=tracking-branches>Tracking branches</h3><p>When you add a remote, git automatically downloads everything&mdash;all commits and all
branches and tags&mdash;from that remote and keeps a copy of it all locally. The branches
end up as locally immutable branches in your local clone called <em>remote-tracking
branches</em>.</p><p>They are locally immutable in the sense that they can only be updated to reflect the
state of the remote when syncing with the remote. You can&rsquo;t update these branches any
other way. The branch names will be prefixed with the remote name, like
<code>my-remote/my-branch</code> and can be safely updated at any time by running <code>git fetch</code>.</p><p>Git allows you to set any other branch as the <em>upstream</em> of a branch. The meaning of
upstream is usually &ldquo;the branch I eventually want my changes merged into&rdquo;. You could set
<code>my-remote/my-branch</code> as the upstream of your current branch like so:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git branch -u my-remote/my-branch
</span></span></code></pre></div><p>When you check the status of your local branch git can now tell you useful information
like &ldquo;Your branch is ahead of &lsquo;my-remote/my-branch&rsquo; by 1 commit.&rdquo; If you periodically
sync with the remote using <code>git fetch</code> you can see how far behind the upstream branch
you are getting.</p></section><section class=outline-2><h3 id=merging>Merging</h3><p>Both of our systems allow branching, but branching isn&rsquo;t very useful without merging. In
the dumb version control system merging is a laborious process of combing through both
versions and creating a combined version.</p><p>With git you can create such a &ldquo;combined&rdquo; version with one command:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git merge another-branch
</span></span></code></pre></div><p>This automatically calculates all the changes on <code>my-branch</code> that don&rsquo;t exist on your
current branch and applies them, creating a new merge commit. Sometimes there are
conflicts, like if both you and them touched the same line in different ways. Git can&rsquo;t
resolve these conflicts automatically so presents them to you to resolve before
completing the merge.</p></section><section class=outline-2><h3 id=rebasing>Rebasing</h3><p>Often when working on a feature for a while you will find your local branch and your
upstream branch will diverge due to other changes happening upstream. If you set your
upstream as above, git will say something like &ldquo;Your branch and &lsquo;my-remote/my-branch&rsquo;
have diverged, and have 8 and 1 different commits each, respectively.&rdquo;</p><p>This means you&rsquo;ve got 8 commits locally that haven&rsquo;t been merged and the upstream has 1
commit that you haven&rsquo;t yet seen. Over time the upstream will get more commits and the
longer this happens, the higher the chances of difficult merge conflicts happening later
(remember, the only point of a branch is to be able to merge it).</p><p>You can keep on top of this by &ldquo;rebasing&rdquo; your local branch on to the upstream like
this:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git rebase
</span></span></code></pre></div><p>What git does is takes those 8 commits on your branch and, one by one, re-applies the
changes to the top of the upstream. This can cause conflicts but the hope is if you
rebase frequently the conflicts are smaller and the changes you are applying are still
fresh in your head. By keeping on top of this you&rsquo;ll never diverge too far from upstream
and be stuck with a difficult merge before you can finish your work.</p><p>Rebasing also allows you to edit the commits as they are being re-applied. This is very
powerful and is one way you can &ldquo;clean up&rdquo; a local working branch ready for it to be
reviewed and merged.</p></section><section class=outline-2><h3 id=resetting>Resetting</h3><p>Reset is one of the scarier git commands and that is somewhat justified given that it
has the <code>--hard</code> option. This is one of the few commands that can actually overwrite
your work. But remember, <strong>no command in git can change, delete or overwrite commits</strong> so,
when in doubt, commit your work!</p><p>Resetting tells git to point your current branch at a different commit. Normally
branches are only updated when you make new commits, as mentioned above. But there a few
reasons why it&rsquo;s useful to point a branch at some other commit.</p><p>One reason to reset is to simply undo any changes in your working directory, this uses
the scary <code>--hard</code> option to intentionally overwrite your working directory.</p><p>Another is to re-commit some changes using a different set of commits. Perhaps you made
a chain of &ldquo;work in progress&rdquo; commits and want to rewrite it as one final commit. You
can <code>--soft</code> reset to the commit before the first WIP commit then commit your changes
again. This can also be achieved with a rebase but sometimes the reset is easier.</p><p>One more reason is if you have a branching model like git&rsquo;s own git repository which has
a <code>next</code> branch for &ldquo;pre-release&rdquo; features. This branch is reset to the top of <code>master</code>
after each release. Complicated branching structures like this aren&rsquo;t recommended if you
don&rsquo;t need them, but git gives you the option.</p><p>Finally, resetting is how you make use of the reflog&mldr;</p></section><section class=outline-2><h3 id=the-reflog>The reflog</h3><p>What happens to the &ldquo;old&rdquo; commits following a rebase or a reset? I&rsquo;ve already mentioned,
and it&rsquo;s worth mentioning again, that no command in git can delete commits. However,
unless you somehow remember their commit hashes, commits are no longer practically
reachable without some kind of reference (ie. a branch or tag).</p><p>That&rsquo;s where the reflog comes in. Since branches are mutable, git keeps a log of all
changes to a branch including commits, rebases and resets. If you want to &ldquo;undo&rdquo; a
rebase or a reset, the reflog is where you need to look. Following a rebase or reset,
the reflog might be the only way to find some commits.</p><p>You can view the reflog for you current branch by running <code>git reflog</code>.</p><p>The reflog will be automatically pruned after 90 days by default. After that time, the
commits themselves will <strong>actually be deleted</strong>. This is to prevent git repos growing
indefinitely. So, yes, I have been lying when I said commits can never be deleted, but
there is a time delay of at least 90 days following any command before they will be. For
this reason you shouldn&rsquo;t be regularly using the reflog to find important commits;
always make sure important stuff is referenced by tags or branches.</p><p>The reflog is your safety rope and I thoroughly recommend exercising your safety rope
until you are confident in how git works. Do a stupid rebase and undo it using the
reflog:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git rebase some-silly-place
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">2</span><span>git reset HEAD@<span style=color:#719e07>{</span>1<span style=color:#719e07>}</span>
</span></span></code></pre></div><p>The way to read the second command is &ldquo;reset my current branch to where my current
branch was one operation ago&rdquo;.</p><p>The reflog can&rsquo;t save you if you&rsquo;re in a detached head state, though, because there&rsquo;s no
ref to record the changes against. This is why git warns you about it and gives you
every opportunity to record the hashes of any commits you make. Just heed the warnings
and be careful in a detached head state.</p></section><section class=outline-2><h3 id=bisecting>Bisecting</h3><p>In the dumb version control system you&rsquo;d probably start deleting old versions at some
point as your disk fills up. Git stores all the copies much more efficiently and people
tend to keep git histories forever. But <em>why</em> do we bother keeping all those old
versions? The answer is often a question: why not? But there is a real answer: we keep
them to track down potential regressions.</p><p>In any long standing project there will eventually be unintended breakage. A user may
report a feature that was working in version 23 is broken in version 24. There could be
hundreds of commits between those versions, but one of them introduced the regression
and finding it can significantly cut down on debugging time.</p><p>Git bisect can efficiently and (semi-)automatically find the commit that first broke the
feature. It looks something like this:</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">1</span><span>git bisect start
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">2</span><span>git bisect bad v24              <span style=color:#586e75># the bad version</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#495050">3</span><span>git bisect good v23             <span style=color:#586e75># the good version</span>
</span></span></code></pre></div><p>Now git will repeatedly checkout commits and let you test them. You can either test them
manually somehow and tell git they are good or bad with <code>git bisect good</code> or <code>git bisect bad</code> or you can run a script to do it completely automatically with <code>git bisect run</code>. It&rsquo;s so cool you&rsquo;ll be wishing for the next opportunity to use it.</p></section></section><section class=outline-1><h2 id=conclusion>Conclusion</h2><p>Version control can be difficult. Some of that difficulty is naturally inherited by
git. Git adds to the difficulty with a somewhat cumbersome UI. But I do believe most of
the difficulties stem from misconceptions and not starting with a basic idea of what
version control is.</p><p>I&rsquo;m amazed by how many people, even experienced developers and git users, think git
stores diffs and does something more clever than our dumb version control system to make
and checkout commits.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> This is a bad start when it comes to understanding git.</p><p>In my career I&rsquo;ve always found myself being the &ldquo;git guy&rdquo;. I don&rsquo;t know why this
is. This article is an attempt for me to teach git in a slightly different way, starting
at a lower level with no preconceptions of what version control is which is, I think,
how I learnt it. Whether this is a useful way to learn or not remains to be seen. I&rsquo;d
love to hear feedback either way!</p></section><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Of course, this is only true if you operate within the confines of git. Git can&rsquo;t
help you if you <code>rm -rf</code> your entire repo or something. There is also garbage
collection, but this can be safely ignored in normal usage and even disabled if you
really wish.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>OK, it does do something a lot more clever than <code>cp -r</code> internally but, as a
user, you do <strong>not</strong> need to know or worry about that. The details are fascinating if you
are interested, though.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><hr><div class=footer><a class=previous-post href="https://blog.gpkb.org/posts/norfolk-coast-path/?ref=footer"><span style=font-weight:700>« Previous</span><br>Norfolk Coast Path</a><div class=next-post><a href="https://blog.gpkb.org/posts/opnsense-pfsense-reply-to/?ref=footer"><span style=font-weight:700>Next »</span><br>Odd Problem Accessing OPNsense Web UI via "OPT1"...</a></div></div></div></main><div class=article-toc><div class=toc-wrapper><h4 id=contents>Contents</h4><ul><li><a href=#top>(Top)</a></li></ul><nav id=TableOfContents><ul><li><a href=#dumb-version-control>Dumb version control</a></li><li><a href=#git-is-dumb-version-control>Git is dumb version control</a></li><li><a href=#doing-dumb-things-with-git>Doing dumb things with git</a><ul><li><a href=#making-a-commit>Making a commit</a></li><li><a href=#checkout-an-old-version>Checkout an old version</a></li><li><a href=#using-meaningful-version-labels>Using meaningful version labels</a></li><li><a href=#what-is-the-current-version-branch>What is the current version/branch?</a></li><li><a href=#syncing-with-a-remote>Syncing with a remote</a></li><li><a href=#differences-between-versions>Differences between versions</a></li></ul></li><li><a href=#beyond-dumb-version-control>Beyond dumb version control</a><ul><li><a href=#composing-commits>Composing commits</a></li><li><a href=#tracking-branches>Tracking branches</a></li><li><a href=#merging>Merging</a></li><li><a href=#rebasing>Rebasing</a></li><li><a href=#resetting>Resetting</a></li><li><a href=#the-reflog>The reflog</a></li><li><a href=#bisecting>Bisecting</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></div></div></body></html>